import json
import pandas as pd
import pika
from datetime import datetime
import matplotlib.pyplot as plt
from prophet import Prophet
import os
import signal
import sys
import smtplib
from email.message import EmailMessage

# --- Configuration ---
RABBITMQ_HOST = "localhost"
QUEUE_NAME = "pm25_processed"
SAVE_FOLDER = "plots"
os.makedirs(SAVE_FOLDER, exist_ok=True)

df_all = pd.DataFrame()
plt.ion()  # Interactive mode ON

# Create two figures: averaged data + prediction
fig_avg, ax_avg = plt.subplots()
fig_pred, ax_pred = plt.subplots()
# --- Compute and return daily-averaged DataFrame ---
def get_daily_average(df):
    df['date'] = pd.to_datetime(df['date'], errors='coerce')
    df['day'] = df['date'].dt.date
    df_daily = df.groupby('day', as_index=False)['pm25'].mean()
    return df_daily

def plot_averaged_data(df):
    ax_avg.clear()

    # --- Compute daily average ---
    df_daily = get_daily_average(df)

    # --- Plot continuous daily data ---
    ax_avg.plot(
        df_daily['day'], df_daily['pm25'],
        color='red', marker='.', markersize=4, linewidth=1, alpha=0.8
    )

    # --- Title and labels ---
    ax_avg.set_title('Averaged PM2.5 sensor data in days', fontsize=13)
    ax_avg.set_xlabel('Datetime', fontsize=11)
    ax_avg.set_ylabel('Value', fontsize=11)

    # --- Format x-axis for every date ---
    ax_avg.set_xticks(df_daily['day'])
    ax_avg.set_xticklabels(df_daily['day'].astype(str), rotation=90, fontsize=7)

    # --- Styling ---
    ax_avg.grid(True, linestyle='--', alpha=0.4)
    fig_avg.tight_layout()

    # --- Draw and save ---
    fig_avg.canvas.draw()
    fig_avg.canvas.flush_events()
    fig_avg.savefig(os.path.join(SAVE_FOLDER, "pm25_averaged_data.png"), dpi=300)

    print("\nüìä Averaged PM2.5 Data plot (daily averages) saved as pm25_averaged_data.png")

    # Print daily average values
    print("\nüóìÔ∏è  Daily Average PM2.5 values:")
    for _, row in df_daily.iterrows():
        print(f"   {row['day']}  ‚Üí  {row['pm25']:.3f}")


# --- Send email with plots ---
def send_email_with_plots(recipient_email):
    sender_email = "omjain990@gmail.com"
    sender_password = "sgkn vlin zbqt rmcz"  # Use App Password if using Gmail

    msg = EmailMessage()
    msg['Subject'] = "PM2.5 Monitoring - Final Plots"
    msg['From'] = sender_email
    msg['To'] = recipient_email
    msg.set_content("Attached are the latest PM2.5 data plots and forecast images generated by the system.")

    # Attach both plots
    for filename in ["pm25_all_readings.png", "pm25_prediction.png"]:
        filepath = os.path.join(SAVE_FOLDER, filename)
        if os.path.exists(filepath):
            with open(filepath, "rb") as f:
                file_data = f.read()
            msg.add_attachment(file_data, maintype="image", subtype="png", filename=filename)

    try:
        with smtplib.SMTP_SSL('smtp.gmail.com', 465) as smtp:
            smtp.login(sender_email, sender_password)
            smtp.send_message(msg)
        print(f"üìß Email sent successfully to {recipient_email}")
    except Exception as e:
        print(f"‚ùå Error sending email: {e}")

# --- Plot Prophet Prediction ---
def plot_prediction(df):
    df = df.dropna(subset=['pm25'])
    if len(df) < 2:
        print("‚ö†Ô∏è Not enough data points for Prophet prediction yet.")
        return

    df_prophet = df.rename(columns={'date': 'ds', 'pm25': 'y'})
    df_prophet['ds'] = pd.to_datetime(df_prophet['ds']).dt.tz_localize(None)

    model = Prophet(daily_seasonality=True)
    model.fit(df_prophet)
    future = model.make_future_dataframe(periods=15)
    forecast = model.predict(future)

    ax_pred.clear()
    ax_pred.plot(forecast['ds'], forecast['yhat'], color='blue', label='Prediction')
    ax_pred.fill_between(forecast['ds'], forecast['yhat_lower'], forecast['yhat_upper'],
                         color='skyblue', alpha=0.4)
    ax_pred.scatter(df_prophet['ds'], df_prophet['y'], color='black', s=15, label='Actual')
    ax_pred.set_title('Visualization - Prediction')
    ax_pred.set_xlabel('Date')
    ax_pred.set_ylabel('PM2.5 Value')
    ax_pred.legend()
    ax_pred.grid(True)

    fig_pred.canvas.draw()
    fig_pred.canvas.flush_events()
    fig_pred.savefig(os.path.join(SAVE_FOLDER, "pm25_prediction.png"))

# --- Signal handler for clean exit ---
def signal_handler(sig, frame):
    print("\n‚ö†Ô∏è Process interrupted. Saving final plots...")
    if not df_all.empty:
        plot_averaged_data(df_all)
        #plot_prediction(df_all)
        print("üíæ Final plots saved. Sending email with attachments...")
        send_email_with_plots("jainom442@gmail.com")
    sys.exit(0)

signal.signal(signal.SIGINT, signal_handler)

# --- RabbitMQ Message Handler ---
def on_rabbitmq_message(ch, method, properties, body):
    global df_all

    msg = json.loads(body)
    ch.basic_ack(method.delivery_tag)
    print("üì© Raw message received:", msg)

    # Detect timestamp key
    timestamp_key = next((k for k in ['timestamp', 'time', 'datetime', 'ts'] if k in msg), None)
    if not timestamp_key:
        print("‚ö†Ô∏è No valid timestamp field found in message. Skipping.")
        return

    # Get PM2.5 value (accepts multiple key names)
    value_key = next((k for k in ['pm25', 'value', 'avg_pm25'] if k in msg), None)
    if not value_key:
        print("‚ö†Ô∏è No valid PM2.5 field found in message. Skipping.")
        return

    temp_df = pd.DataFrame([{
        'date': pd.to_datetime(msg[timestamp_key]),
        'pm25': float(msg[value_key])
    }])

    df_all = pd.concat([df_all, temp_df]).drop_duplicates(subset='date').sort_values('date')

    print("‚úÖ Updated PM2.5 data:")
    print(df_all.tail())

    plot_averaged_data(df_all)
    #plot_prediction(df_all)

# --- RabbitMQ Consumer ---
def rabbitmq_consumer():
    connection = pika.BlockingConnection(pika.ConnectionParameters(RABBITMQ_HOST))
    channel = connection.channel()
    channel.queue_declare(queue=QUEUE_NAME, durable=True)
    channel.basic_consume(queue=QUEUE_NAME, on_message_callback=on_rabbitmq_message)
    print("‚è≥ Waiting for messages in RabbitMQ queue...")
    channel.start_consuming()

if __name__ == "__main__":
    rabbitmq_consumer()
